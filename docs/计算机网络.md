# HTTP

## 状态码
**1xx: 信息响应**

- **100 Continue**：请求已接收，客户端应继续发送请求的其余部分。
- **101 Switching Protocols**：服务器将切换协议（websocket时进行http连接成功后需要切换到 websocket时的响应码）。

**2xx: 成功**

- **200 OK**：请求成功，服务器返回所请求的数据。
- **201 Created**：请求成功并且服务器创建了资源。
- **202 Accepted**：请求已接受，但尚未处理完成。
- **204 No Content**：请求成功，但不返回任何内容。

**3xx: 重定向**

- **301 Moved Permanently**：请求的资源已被永久移动到新位置。
- **302 Found**：请求的资源临时移动到新位置，客户端应继续使用原有URL。
- **304 Not Modified**：资源未修改，可以使用缓存的版本。

**4xx: 客户端错误**

- **400 Bad Request**：请求有误，服务器无法理解。
- **401 Unauthorized**：请求需要身份验证。
- **403 Forbidden**：服务器理解请求，但拒绝执行。
- **404 Not Found**：请求的资源未找到。
- **405 Method Not Allowed**：请求方法不允许用于请求的资源。



**5xx: 服务器错误**

- **500 Internal Server Error**：服务器遇到错误，无法完成请求。
- **501 Not Implemented**：服务器不支持请求的功能。
- **502 Bad Gateway**：服务器作为网关或代理时从上游服务器收到无效响应。
- **503 Service Unavailable**：服务器当前无法处理请求，通常是由于超载或维护。
- **504 Gateway Timeout**：服务器作为网关或代理，未能及时从上游服务器获得响应。

## HTTP缓存
强缓存：强缓存通过 Cache-Control 和 Expires 控制。

协商缓存：通过  If-Modified-Since  和 If-None-Match  控制。



过程：

首先在发起下一次请求前找到响应头  Cache-Control（http1.1及以后）中的 max-age  或  Expires（http1.0）  来判断缓存的资源是否过期，如果过期则向服务器发起请求并在  If-Modified-Since  中携带资源修改的最后日期或者 在  If-None-Match  中携带资源的唯一标识，服务器收到请求后，会根据请求头中这些字段的值对比服务器对应的值，如果相同则返回 304 not modified 状态码，不同则返回新的资源并且更新 Etag 或者  Last-Modified  响应头给客户端。



Cache-Control：HTTP1.1引入的头字段， 主要用于定义缓存策略。它有多种指令，可以用来控制缓存的行为： 

-  max-age：资源缓存最大时间（单位为秒）
- no-cache：缓存该资源，但每次使用前都需要与服务器确认资源是否有效
- no-store：完全不缓存资源

Expires： HTTP/1.0中的缓存控制字段，是资源过期的一个时间节点。

ETag：资源唯一标识符，在协商缓存中的 If-None-Match 请求头中携带。

Last-Modified：资源修改的最后时间，在协商缓存中的 If-Modified-Since 请求头中携带。

## HTTP各个版本之间的差异
### HTTP1.0

**优点：**

- 支持了**GET**、**POST**、HEAD等请求方法。
- 引入了HTTP**头字段**、**状态码**，可以传输多种数据格式。

**缺点**：

- **每个请求都要建立新的TCP连接**：网络开销大，导致性能较差。
- **没有持久连接**：每次传输一个资源都要新建连接，容易浪费资源。



### HTTTP1.1

持久连接（HTTP Persistent Connections）是为了解决此问题提出的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 

**优点：**

- 引入了持久连接，允许多个请求复用同一个TCP连接。
- 增加了更多请求方法，如PUT、DELETE、OPTIONS等。
- 增加  Cache-Control  头字段，实现灵活的缓存控制策略。
- 管道化支持， 将同一个连接分解为多个管道，给每个请求分配在不同的管道，加快数据传输速度，减少理论等待时间。



**缺点**：

- **队头阻塞问题**：即便一个请求已经发出，后续请求必须等待前面的请求处理完才能进行，阻碍了并发性能。
- **连接复用效率低**：虽然支持持久连接，但在大量请求时，TCP连接的复用效率不高。



### HTTP2.0

**优点**：

- **二进制传输：**于2015年发布，带来了协议的重大升级，基于二进制格式进行数据传输。
- **多路复用**： 多个请求可以并发发送，减少队头阻塞的影响、大大提高了传输效率。  （在某个管道堵塞时，后续请求可以使用其他空闲管道进行发送）
- **头部压缩**：通过HPACK算法压缩请求头，减少传输体积，提升性能。  
- **服务器推送**：服务器可以主动推送资源给客户端，减少客户端请求的延迟。  



**缺点**：

- **复杂性增加**：相比HTTP/1.x，HTTP/2的实现更加复杂，增加了调试和维护的难度。
- **依赖TCP**：HTTP/2仍然基于TCP，因此在高丢包率环境中，多路复用的优势会因TCP的头部阻塞问题而减弱。
- **服务端推送不常用**：虽然引入了Server Push，但实际应用中并不广泛，容易导致不必要的资源推送和带宽浪费。



### HTTP3.0

**特点**：

- 基于QUIC协议，绕过了TCP，直接使用UDP来提高传输效率。
- 提供了内建的加密，所有通信都是加密的。
- 解决了TCP中的队头阻塞问题。

**缺点**：

- **兼容性问题**：由于是新的协议，一些旧系统或防火墙可能不支持或阻挡QUIC流量。
- **复杂性增加**：QUIC协议和HTTP/3进一步增加复杂度。

## 头字段
- ### 请求头

  -  Host： 目标服务器的**域名**和**端口**号。  
  -  User-Agent：客户端操作系统信息标识
  -  Accept： 客户端能够处理的内容类型，服务器可以根据这个字段返回适合的响应内容。
  -  Accept-Encoding：客户端支持的内容编码方式。
  -  Accept-Language： 客户端期望接收的语言。
  -  Content-Type：本次发起请求的数据类型。
  -  Authorization：认证信息。
  -  Cookie： 用于身份验证和会话管理。  
  -  Referer： 当前请求的源地址
  - If-Modified-Since：协商缓存时携带 Last-Modified 的值给服务器。
  - If-None-Match：协商缓存时携带 Etag 的值给服务器。

  ### 响应头

  - Content-Type： 服务器返回内容的内容类型
  -  Content-Length： 响应体的字节数  
  -  Content-Encoding： 服务器使用的内容压缩方式，告诉客户端如何解压响应内容。
  -  Cache-Control：缓存策略，控制缓存行为。
  -  Expires： 资源的过期时间。
  -  Access-Control-Allow-Origin： 跨域资源共享（CORS），定义哪些域可以访问资源。
  -  Location： 用于重定向时，服务器告诉客户端应该访问的URL。
  - Etag：资源唯一标识符，用于缓存验证。
  - Last-Modified：资源修改的最后时间，用于缓存验证。

  ### 通用头字段

  -  Connection： 用于控制连接的行为，常见的值是`keep-alive`（保持连接）和`close`（关闭连接）。
  -  Date：请求/响应成功的日期。

## HTTPS
HTTPS基于SSL/TLS协议上建立的超文本传输安全协议，它们通过加密、身份验证、数据完整性保护实现了HTTPS。

- SSL： 是一种安全协议，主要用于在互联网中提供加密通信的方式。
- TLS： TLS 是 SSL 的升级版本，增强安全性能。



### HTTPS通信过程

**TCP握手**

1. **第一次握手-客户端发送 SYN** ： 客户端主动发起连接，发送一个带有 SYN标志位的TCP报文段，表示要与服务器建立连接，这个报文包含了初始序列号（`Seq = X`）。

- **客户端状态：**`SYN_SENT`（等待服务器回应）
- **目的：** 通知服务器，客户端想要建立连接，并同步序列号。



1. **第二次握手-服务器回应 SYN-ACK**： 服务器收到客户端的 SYN 请求后，确认收到请求，发送一个带有 SYN 和 ACK 标志位的TCP报文段。

- SYN：服务器同意建立连接并同步序列号，服务器自己也生成一个初始序列号（`Seq = Y`）。
- ACK：表示确认收到客户端的 SYN，确认号为 `Ack = X + 1`，表明已收到并准备接受客户端的下一段数据。
- **服务器状态：**`SYN_RCVD`（已收到客户端请求，等待客户端确认）
- **目的：** 同步服务器的序列号，并确认客户端的序列号。



1. **第三次握手-客户端发送 ACK**： 客户端收到服务器的 SYN-ACK 后，发送最后一个 ACK 报文段来确认收到服务器的 SYN 报文。  

- ACK 标志位被设置，确认号为 `Ack = Y + 1`，表明客户端已接收到服务器的序列号并准备接收服务器的数据。
- **客户端状态：**`ESTABLISHED`（连接已建立）
- **服务器状态：**`ESTABLISHED`（连接已建立）
- **目的：** 确认双方的序列号已经同步，正式建立连接。



**TLS握手**

不同的密钥交换算法，TLS 的握手过程可能会有一些区别。使用非对称加密方式保护对称加密密钥，这个工作就是密钥交换算法负责的。



将 TLS 证书部署服务端（证书文件存在公钥）， TLS 握手阶段将证书传递给客户端，服务端保存私钥。

客户端会生成随机密钥，使用服务端的公钥加密后再传给服务端。根据非对称加密算法，服务端用私钥解密后，双方就得到了相同的密钥，再用它加密应用消息。



RSA 密钥交换算法的TLS握手过程：

1. TLS 第一次握手：客户端会发送一个消息给服务端，该消息包含 **客户端 TLS 版本号**、**支持的密码套件**、**生成随机数1。**
2. TLS 第二次握手：

- 当服务端收到客户端的消息后，首先确认 **使用的TLS 版本**、并 **选择一个密码套件**、**生成随机数2**后，将这个消息传递给客户端。
- 之后，服务端会再次发送一个包含数字证书的消息给客户端， 数字证书是用来认证公钥持有者（服务端）的身份，告诉客户端该服务端是合法的。

1. TLS 第三次握手：

- 客户端验证完证书，客户端就会生成一个**随机数3** ，用证书上的服务器公钥加密该随机数，并发送给服务器；服务器收到后，私钥解密得到随机数3，这是双方获得了3个随机数，并且会根据**这三个随机数生成对称密钥**。
- 生成对称密钥后，客户端在发送一个消息，告诉服务端开始使用加密方式发送消息。

1. TLS 第四次握手：服务器给客户端发送一个消息，告诉客户端开始使用加密方式发送消息。



**tips：二次握手之后客户端需要验证证书是否值得信任**



数字证书：持有者公钥、持有者、用途、CA签名、CA签名算法、证书有效期等。（CA机构：网络世界里的公安局、公证中心，具有极高的可信度）

CA证书颁发过程：

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash，得到一个Hash值。
- CA 用自己的私钥对该 Hash 加密生成CA签名。

客户端校验数组证书：

- 客户端使用相同算法对公钥、用途、颁发者、有效时间等信息计算哈希值H1。
- 客户端用预先保存的 CA 公钥对证书上的 CA 签名解密，得到哈希值H2.
- 对比H1 和 H2 若相同则证明证书值得信赖。