# 下一代跨端组件库-Quark Design（哈啰出版）
Quark design，简称Quarkd。是一种全新的组件库，底层基于Web Components，不同于传统组件框架（如Antd, Vant），需要浏览器中需要做大量前置工作。Quarkd则将这些工作放到构建应用程序的编译时来处理。组件的数据更新响应由浏览器自身API处理，更简单，更高效！

由哈啰平台 UED 和增长&电商前端团队联合打造的一套面向移动端的跨框架 UI 组件库。

from [Quarkd官网](https://quark-ecosystem.github.io/quarkd-docs/vue/#/)

![哈啰跨端组件库](/哈啰跨端组件库.png)

## 与主流组件库的区别
Quark 能同时运行在业界所有前端框架/无框架工程中，基于Web Components 实现。
特点：
- 不依赖技术栈（eg. Vue、React、Angular等）
- 不依赖技术栈版本(eg. Vue2.x、Vue3.x)
- 全新的Api设计（eg. 弹窗的打开属性由传统的 Visible 调整为符合浏览器原生弹窗的 open等）
- 公司在多框架项目架构中，能够保持ui和交互层面的统一，减少开发和维护的心智负担。 
- 支持按需引用
- 支持定制主题

## Web Components
Web Component 是一套不同的技术，允许你创建可重用的定制元素（它们的功能封装在你的代码之外）并且在你的 web 应用中使用它们。--MDN  
  
Web Components 旨在解决这些问题 — 它由三项主要技术组成，它们可以一起使用来创建封装功能的定制元素，可以在你喜欢的任何地方重用，不必担心代码冲突。

**特点：**
- **Custom Elements（自定义元素）**:允许开发者创建自定义的 HTML 标签，使用 JavaScript 定义其行为和生命周期方法，例如 connectedCallback、disconnectedCallback 等。这使得我们可以创建独特的标签和组件，并且具备灵活的功能和交互。
- **Shadow DOM（影子 DOM）**：提供了封装功能，创建出独立的 DOM 子树。这个子树不会被外部的 CSS 或 JavaScript 影响，从而保持组件的样式和行为独立。这种封装有助于防止样式冲突，使组件更加模块化。
- **HTML Templates（HTML 模板）**：使用 `<template>` 和 `<slot>` 标签来定义可以复用的 HTML 结构。在 `<template>` 内部的内容不会立即渲染，只有在需要时通过 JavaScript 克隆和使用。这种模板化的方式使得创建复杂的 HTML 结构更加高效，尤其适用于复用场景。

  
**应用场景**
Web Components 常用于构建可复用的 UI 组件库、独立封装的部件（如按钮、弹窗、输入框等），以及跨框架的应用开发。它可以用来实现任何需要封装、复用、模块化的功能，尤其适合需要跨团队、跨项目共享的组件。

### 自定义元素
### 影子 DOM
### 模板和插槽

## 性能优势-优先逻辑无阻塞
对 React 组件的 Web Components 实现中，一般的 React 组件在初次执行时需要一次性走完所有必须的节点逻辑，而这些逻辑的执行都同步占用在 js 的主线程上，当页面很复杂时，一些非核心逻辑就将会阻塞后面的核心逻辑的执行。

例如：一个复杂的交互组件中包含多个子按钮小组件，页面首次加载时不应该优先加载这些细节逻辑，而是优先渲染整体核心逻辑，而后再去加载这些细节功能。

使用 Web Components 来优化上述 React 场景将会变得简洁的多，只需要在 React 执行一次 createElement 并实现核心逻辑，细节实现可以在后续合适的时机执行。

技术实现：通过 Web Components 中的 Shadow DOM 实现。

## 组件隔离
Shadow DOM 是一种用于隔离组件内部样式和结构的技术。它允许开发者为组件创建独立的 DOM 树（即 Shadow Tree），与主页面的 DOM 分开，这样可以避免样式冲突和结构上的干扰。

页面中的 DOM 节点数越多，运行时性能将会越差，这是因为 DOM 节点的相互作用会时常在触发重绘（Repaint）和重排（reflow）时会关联计算大量 Frame 关系。

而对 CSS 的隔离也将加快选择器的匹配速度，即便可能是微秒级的提升，但是在极端的性能情况下，依然是有效的手段。

## Quarkd 2.0
这是自 Quarkd 开源以来第二个重大版本。本次升级主要实现了组件外部可以穿透影子Dom，修改组件内部元素的任何样式。

需求促使更加高效的工具发展：前端技术和框架发展多年，很多公司有大量的前端项目且开发框架不一，Quarkd 正是为了解决各类不同的技术栈下 ui 交互的统一。

由于 1.0 版本中的shadow dom 特性决定了其“孤岛”的属性，组件内部是个独立于外部，外部无法修改组件内部样式，若要修改内部样式，在 quarkd 1.x 版本中采用 CSS 变量的方式实现。
**局限性**：只能修改预设css变量的指定样式，当源码中没有指定的css变量，就意味着你无法通过css变量从外面渗透进入组件内部去修改。

```html
// 使用组件
<quark-dialog class=“dialog” content="哈啰技术"></quark-dialog>

// 内部css源码
:host .quark-dialog-content {
    font-size: var(--dialog-content-font-size, 14px);
    color: var(--dialog-content-color, "#5A6066");
    // ... more样式
}
```
若要修改样式，则外部需要编写以下代码：
```css
.dialog {
    --dialog-content-font-size: 36px;
    --dialog-content-color: red;
}
```

**2.0的改进**：使用 `::part` + 伪元素的形式解决。将 Quarkd 主要 dom 节点进行改造，通过如下方式来自定义任何组件样式。
::part 可以用来表示在阴影树中任何匹配 part 属性的元素。
```css
  custom-element::part(foo) {
    /* 样式作用于 `foo` 部分 */
  }
```
```html
<quark-dialog class=“dialog” content="哈啰技术"></quark-dialog>

.dialog::part(body) {
    font-size: 32px;
    color: #333;
}
.dialog::part(footer) {
    font-size: 16px;
    color: #666;
}
```





