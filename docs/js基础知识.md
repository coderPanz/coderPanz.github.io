# 

JS基础知识

完整的JS实现包括以下几个部分

- JS核心，ECMAScript，ECMAScript 是一种由 Ecma International(欧洲计算机制造商协会) 标准化的脚本语言规范，是javascript的核心。
- 文档对象模型，DOM
- 浏览器对象模型，BOM

## JS核心

ES5新增特性：

- 原生的解析和序列化JSON数据的JSON对象
- 严格模式。

ES6新增特性：

- 块级作用域：引入了  `let`  和  `const`  关键字，用于声明块级作用域的变量和常量。
- 箭头函数：提供了更简洁的函数定义语法。
- 模板字符串：使用**反引号**（`）来创建字符串模板，支持插入变量
- 解构赋值：可以从数组或对象中把值给提取出来
- 函数默认参数：当函数没有实参传进来时，会使用默认参数。
- 展开运算符：使用  `... ` 语法可以将数组、对象等进行展开，方便地进行合并、复制等操作。
- 支持类：class，定义属性和方法，支持继承。
- 模块化：支持import、export导入导出。
- 迭代器和生成器：使得迭代更加高效和方便
- Promise：期约引用类型，有效支持和组织异步逻辑。
- 反射和代理：提供了拦截并向基本操作(get/set等)嵌入额外能力行为的能力
- 新增的数据类型：Map、WeakMap、Set、WeakSet、Symbol。

ES7新特性：少量语法层面加强，包括数组的 `includes` 方法，指数运算符 `Math.pow()` 

ES8新特性：增加了异步函数 `async/await` ，和一些对象的API：`Object.values()`:对象转数组  /  `Object.entries()`:对象转数组等。



## DOM

​		文档对象模型，是一个应用编程接口，用于在HTML中使用扩展的XML。DOM将整个页面抽象为一组分层的节点也就是DOM树。并且可以使用DOM提供的API对节点进行 ***增删改查*** ，从而可以使得开发者随意控制网页内容和结构。

1. `document.getElementById()`：通过元素的 ID 获取对应的元素节点。
2. `document.getElementsByClassName()`：通过类名获取一组元素节点。
3. `document.querySelector()`：通过选择器获取匹配的第一个元素节点。
4. `document.querySelectorAll()`：通过选择器获取匹配的所有元素节点。
5. `parentNode.childNodes`：获取父节点的所有子节点列表。
6. `element.innerHTML`：获取或设置元素的 HTML 内容。
7. `element.textContent`：获取或设置元素的文本内容，不包含 HTML 标签。
8. `element.setAttribute()` 和 `element.getAttribute()`：设置和获取元素的属性。
9. `element.style`：访问元素的 CSS 样式属性。
10. `element.addEventListener()`：为元素添加事件监听器。
11. `element.removeChild()` 和 `element.appendChild()`：移除和添加子节点。
12. `element.classList`：访问元素的类名列表，方便操作元素的样式类。



## BOM

浏览器对象模型，用于支持访问和操作浏览器的窗口，操作浏览器显示页面之外的部分。

- 弹出新浏览器窗口的能力
- 移动、缩放和关闭浏览器的能力
- navigator对象，提供关于浏览器的详细信息
- location对象，提供浏览器加载页面的详细消息
- 对cookie的支持



## 严格模式

​	ES5增加了严格模式的概念，严格模式是一种 不同的JS解析和执行模型，ES3的一些不规范的写法在这种模式下会被处理，对于不安全的活动会抛出错误。通过在脚本上方加上 `"use strict"` 启用，或者在函数内部的开头启用。

ES3的一些不规范的写法：

1. 变量未声明直接赋值：在非严格模式下，未声明的变量会被隐式创建为全局变量，而在严格模式下会抛出错误。
2. 删除不可删除的属性：在非严格模式下，使用 `delete` 操作符删除不可删除的属性时会静默失败，而在严格模式下会抛出错误。
3. 对象字面量重复属性名：在非严格模式下，定义对象字面量时重复的属性名会被忽略，而在严格模式下会抛出错误。



一些不安全的活动可能包括：

1. 未声明就使用变量。
2. 对只读属性进行赋值操作。
3. 使用 `eval()` 函数执行字符串作为代码，存在安全风险。
4. 修改内建对象的原型（如修改 `Array.prototype`）。
5. 在函数中使用 `arguments.callee` 或 `arguments.caller`，它们在严格模式下已被禁止使用。



## 变量声明

### var  关键字

​		变量声明未赋值的情况下会保存  `undefined` 这个特殊值。在函数内部通过 `var` 定义的变量为**局部变量**并会形成**局部作用域**，在函数外部无法访问并在函数执行后会被销毁。当然，无论是 `var` 还是 `let/const` ，在函数内部声明的变量在函数外部都无法访问。

​		`var` 声明的变量会出现**声明提升(把变量声明提升这个动作到作用域顶部)**现象。注意这里是指声明的提升，并没有进行赋值，所以访问即为 `undefined`。

```js
console.log(a) // undefined
var a = 1 // 这里才是变量的赋值

console.log(b) // b is not defined
```



### let和const关键字

​	`let/const` 关键字声明在代码块中声明的变量会形成**块级作用域**，只能在该块中才能访问。并且 `let/const` 声明的变量没有**声明提升**。使用 `const` 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此优先推荐使用 `const` 来声明变量，除非你确定声明的变量在接下来会改变在使用 `let` 。



## 数据类型

ES中有6种简单的数据类型，也叫**原始类型**。分别是，

**Undefined** ：该类型只有一个值， `undefined` 声明变量未赋值时，变量会自动保存该值。该值是一个假值。

**Null**：该类型只有一个值， `null` 。表示一个一个空对象指针，使用 `typeof` 判断时返回  'object'。在声明一个即将保存对象的变量时建议使用 `null` 来赋值。它也是一个假值。

**Boolean**：两个字面值：`true`、`false`。 注意：它们不等于数值1和0。

**Number**：数值类型，NaN表示不是数值的意思(not a number)

**String**：字符串类型

**Symbol**： 符号类型，符号的实例是唯一的、不可变的。符号的用途是确保对象属性使用唯一的标识符，不会发生属性冲突的危险。`Symbol('abb')` 可以传入一个字符串参数作为对符号的描述，这个参数与符号的定义完全无关。注意：

`Symbol('abb') !== Symbol('abb')`

可以使用 `typeof` 操作符来判断类型，它会返回表示该类型的字符串。

​	**注意**：调用 `type null` 时会返回  `object` ，这是因为 `null` 被认为指向一个空对象。严格来说，ES中函数也是对象，并不代表一种数据类型，但是函数也有自己特殊的属性。因此，就有必要通过 `typeof` 操作符来区分函数和对象。



## break、continue、return

break和continue语句是为执行循环代码提供了更加严格的控制手段，`break` 语句会使得代码**立即退出并结束当前循环**。`continue` 语句也是用于**立即本次循环并开始下一次循环**。`return` **结束循环，后面的语句不执行**

```js
for(let i = 0; i < 5; i++) {
  if(i === 3) break
  console.log(i) // 0 1 2
}

for (let i = 0; i < 5; i++) {
  if (i === 3) continue
  console.log(i) // 0 1 2 4
}

for (let i = 0; i < 5; i++) {
  if (i === 3) return
  console.log(i) // 0 1 2
}
```