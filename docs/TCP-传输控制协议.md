# TCP-传输控制协议

## 介绍

**传输控制协议**，是一种面向连接的、可靠的、基于[字节流](https://zh.wikipedia.org/wiki/字節流)的[传输层](https://zh.wikipedia.org/wiki/传输层)[通信协议](https://zh.wikipedia.org/wiki/通信协议)。在简化的计算机网络[OSI 模型](https://zh.wikipedia.org/wiki/OSI模型)中，它完成第四层传输层所指定的功能。[用户数据报协议](https://zh.wikipedia.org/wiki/用户数据报协议)（UDP）是同一层内另一个重要的传输协议。

数据在 TCP 层称为流（Stream），数据分组称为分段（Segment）。

## 运作方式

​ TCP 协议的运行可划分为三个阶段：连接创建、数据传送、连接终止。操作系统将 TCP 连接抽象为[套接字](https://zh.wikipedia.org/wiki/Berkeley套接字)表示的本地端点，作为编程接口给程序使用。

### 创建通路

​ TCP 用三次[握手](<https://zh.wikipedia.org/wiki/握手_(技术)>)过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。

服务器端执行了 listen 函数后，就在服务器上创建起两个队列：

- SYN 队列：存放完成了二次握手的结果。 队列长度由 listen 函数的参数 backlog 指定。
- ACCEPT 队列：存放完成了三次握手的结果。队列长度由 listen 函数的参数 backlog 指定。

三次握手协议的过程：

1. 客户端（通过执行 connect 函数）向服务器端发送一个 SYN 包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数**A**作为消息序列号。
2. 服务器端收到一个合法的 SYN 包后，把该包放入 SYN 队列中；回送一个 SYN/ACK。ACK 的确认码应为**A+1**，SYN/ACK 包本身携带一个随机产生的序号**B**。
3. 客户端收到 SYN/ACK 包后，发送一个[ACK 包](https://zh.wikipedia.org/wiki/確認訊息)，该包的序号被设定为**A+1**，而 ACK 的确认码则为**B+1**。然后客户端的 connect 函数成功返回。当服务器端收到这个 ACK 包的时候，把请求帧从 SYN 队列中移出，放至 ACCEPT 队列中；这时 accept 函数如果处于阻塞状态，可以被唤醒，从 ACCEPT 队列中取出 ACK 包，重新创建一个新的用于双向通信的 sockfd，并返回。

“三次握手”的目的是“为了防止已失效的连接(connect)请求报文段传送到了服务端，因而产生错误”，也即为了解决“网络中存在延迟的重复分组”问题。例如：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 发出的一个新的连接请求。于是就向 client 发出确认报文段，同意创建连接。

四次挥手过程:
四次挥手：在终止 TCP 连接时，客户端和服务器之间进行四次挥手来完成连接的关闭。首先，客户端发送一个带有 FIN（结束）标志的数据包给服务器；然后服务器回复一个带有 ACK 标志的数据包作为回应；接着，服务器发送一个带有 FIN 标志的数据包给客户端；最后，客户端回复一个带有 ACK 标志的数据包，表示挥手完成。

### 数据传输

​ 在 TCP 的数据传送状态，很多重要的机制保证了 TCP 的可靠性和强壮性。它们包括：使用序号，对收到的 TCP 报文段进行排序以及检测重复的数据；使用校验和检测报文段的错误，即无错传输[[3\]](https://zh.wikipedia.org/wiki/传输控制协议#cite_note-3)；使用确认和计时器来检测和纠正丢包或延时；流控制（Flow control）；拥塞控制（Congestion control）；丢失包的重传。

#### 可靠传输
TCP通过序列号、确认机制和重传机制来实现可靠传输。发送方给每个数据包分配一个唯一的序列号，并等待接收方的确认信息。如果发送方未收到确认信息，将会进行超时重传。接收方根据序列号来确认已接收的数据，并且可以重新请求丢失的数据。

- 基于重复累计确认的重传：如果一个包（不妨设它的序号是 100，即该包始于第 100 字节）丢失，接收方就不能确认这个包及其以后的包，因为采用了累计 ack。接收方在收到 100 以后的包时，发出对包含第 99 字节的包的确认。这种重复确认是包丢失的信号。发送方如果收到 3 次对同一个包的确认，就重传最后一个未被确认的包。阈值设为 3 被证实可以减少乱序包导致的无作用的重传（spurious retransmission）现象。[[4\]](https://zh.wikipedia.org/wiki/传输控制协议#cite_note-4) [选择性确认](https://zh.wikipedia.org/wiki/传输控制协议#选择性确认)（SACK）的使用能明确反馈哪个包收到了，极大改善了 TCP 重传必要的包的能力。

- 超时重传：发送方使用一个保守估计的时间作为收到数据包的确认的超时上限。如果超过这个上限仍未收到确认包，发送方将重传这个数据包。每当发送方收到确认包后，会重置这个重传定时器。

#### 流量控制

[流量控制](<https://zh.wikipedia.org/wiki/流量控制_(数据)>)用来避免主机分组发送得过快而使接收方来不及完全收下，一般由接收方通告给发送方进行调控。

TCP 使用[滑动窗口协议](https://zh.wikipedia.org/w/index.php?title=滑动窗口协议&action=edit&redlink=1)来进行流量控制, 接收方会告知发送方自己的接收窗口大小，发送方根据接收方的处理能力和网络状况来控制发送的数据量，以避免接收方被压倒或网络拥塞。

#### 超时重传

#### 拥塞控制

[拥塞控制](https://zh.wikipedia.org/wiki/TCP拥塞控制)是发送方根据网络的承载情况控制分组的发送量，以获取高性能又能避免拥塞崩溃（congestion collapse，网络性能下降几个数量级）。这在网络流之间产生近似[最大最小公平](https://zh.wikipedia.org/w/index.php?title=最大最小公平&action=edit&redlink=1)分配。

发送方与接收方根据确认包或者包丢失的情况，以及定时器，估计网络拥塞情况，从而修改数据流的行为，这称为拥塞控制或网络拥塞避免。

TCP 的现代实现包含四种相互影响的拥塞控制算法：[慢开始](https://zh.wikipedia.org/wiki/慢开始)、拥塞避免、[快速重传](https://zh.wikipedia.org/wiki/TCP拥塞控制#快速重传)、[快速恢复](https://zh.wikipedia.org/wiki/TCP拥塞控制#快速恢复)。

- 慢开始：起初以较低的速率发送数据，然后逐渐增加发送速率。
- 拥塞避免：当网络没有出现拥塞的迹象时，继续以较慢的速率增加发送速率。
- 快重传：在接收方连续收到相同的数据包时，可以不必等待超时重传，而是立即重传丢失的数据包。
- 快恢复：在发生拥塞时，通过减少发送速率而不是中断连接来降低网络的负载。

此外，发送方采取“超时重传”（retransmission timeout，RTO），这是估计出[来回通信延迟](https://zh.wikipedia.org/wiki/來回通訊延遲) (RTT) 以及 RTT 的方差。
