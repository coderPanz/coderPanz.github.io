# 浏览器事件循环

## 介绍

​		JavaScript事件循环是 JavaScript 运行时处理异步操作的核心机制之一。它是一个循环，负责监听事件队列中的事件，并且在队列不为空时，将事件按照特定的顺序进行处理。其实js只是一个脚本需要具体的运行环境才能体现出它的特性，所以js存在浏览器事件循环和nodejs事件循环。这里先介绍浏览器事件循环

## JS单线程问题

1. JS为什么会存在事件循环呢?	

   ​		因为JS是单线程的语言，但是其中存在同步和异步的概念，它没有很多个线程来同时执行很多的异步任务，所以当遇到异步任务时会阻塞js的执行。事件循环就是用来解决这一问题的。

2. 那为什么js是单线程的？这样设计有什么好处？

   - why

   ​		JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？

   - 好处

     ​	相比于多线程，单线程模型更容易管理内存、同步问题（在多线程环境下，如果多个线程同时修改共享的数据）和死锁（死锁（Deadlock）是指在多线程或并发编程环境中，两个或多个线程无限期地等待对方持有的资源，导致它们都无法继续执行的情况。）等并发问题，从而降低了实现的复杂度。

3. 为什么说是单线程的那为什么能够同时执行主线程代码和异步代码？

   这是因为浏览器是多线程的，当 JS 需要执行异步任务时，浏览器会另外启动一个线程去执行该任务。也就是说，JavaScript是单线程的指的是执行JavaScript代码的线程只有一个，而且浏览器还存在着网络请求线程，渲染线程等。

   例如：比如主线程发起请求，就会把这个任务交给异步 HTTP 请求线程去执行，等请求数据返回之后，再将 callback 里需要执行的 JS 回调交给 JS 引擎线程去执行。



## 浏览器事件循环

### 同步任务和异步任务

- 同步任务：在主线程上排队执行的任务。
- 异步任务：不进入主线程，而存在于任务队列中的任务，多个异步任务也需要排队执行。

### 执行栈和任务队列

- 执行栈：基于栈这一数据结构实现，遵循**先进后出**的原则。**它主要负责跟踪所有要执行的代码**。简单介绍下执行栈流程

  - js代码开始执行时，创建全局执行上下文，并压入执行栈
  - 遇到函数调用时，创建函数执行上下文，并压入执行栈
  - 函数执行完毕，对应的函数执行上下文也被推出栈中，然后继续执行全局上下文
  - 所有代码执行完毕，全局上下文也会被推出栈中，程序结束

- 任务队列：基于队列这一数据结构实现，用来保存异步任务，遵循**先进先出**的原则。**主要负责将新的任务发送到队列中进行处理。**简单介绍下任务队列流程

  - JavaScript在执行代码时，会将同步的代码按照顺序排在执行栈中。当遇到异步任务时，就将其放入任务队列中，等待当前执行栈所有同步代码执行完成之后(因为压入执行栈中的全局执行上下文中可能包含异步代码，遇到异步代码时就放入任务对列中)，在从异步任务队列中取出已完成的异步任务的回调并将其放入执行栈中继续执行，如此循环往复，直到执行完所有任务。

  

### 队列和任务类型

由于异步代码的种类不同，事件循环中会被放入不同的任务对列中。可以分为

- 宏任务队列
- 微任务队列

任务也可以分为

- 宏任务：setTimeout(定时器)、setInterval(轮询)、I/O、UI 交互事件、setImmediate(Node.js 环境)
- 微任务：Promise（使用 `Promise` 对象的 `then()` 方法注册的回调函数会被放入微任务队列中）、MutaionObserver(当 DOM 结构发生变化时，注册的回调函数会被放入微任务队列中。)、process.nextTick(Node.js 环境)

### 任务队列执行过程

总结：宏一微多

1. JS引擎首先从宏任务队列中取出第一个任务并执行。
2. 上一个宏任务执行完成后，将微任务中的所有任务取出并依次执行。执行过程中产生新的微任务也会在本轮中一并执行。
3. 上一轮微任务全部执行完成后，继续从宏任务取出一个并执行。以此循环往复。

#### 执行顺序

```js
console.log('Start');

setTimeout(function() {
  console.log('setTimeout');
}, 0);

Promise.resolve().then(function() {
  console.log('Promise');
});
console.log('End');

// Start End Promise setTimeout

async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
async1();
setTimeout(() => {
  console.log("timeout");
}, 0);
new Promise(function (resolve) {
  console.log("promise1");
  resolve();
}).then(function () {
  console.log("promise2");
});
console.log("script end");

// (async1 start) (async2) (promise1) (script end) (async1 end) (promise2) (timeout)
```