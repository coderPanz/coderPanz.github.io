# 防抖-节流

## 介绍

防抖和节流本质上是优化了**高频率的执行代码**带来的性能损耗的一种技术手段!

例如，优化用户对设备进行高频率的交互操作。鼠标**频繁**点击、滚动、用户频繁的输入。这些频繁的动作会不断的调用事件处理函数，极大地浪费资源，降低前端页面性能！通过**防抖和节流**可以来很好的限制这些高频操作。


## 节流

**节流**：触发的事件处理函数在n秒内只运行一次，若在此期间内再次触发函数不再生效！

每次调用函数的时候获取当前，计算等待时间。若等待时间小于等于0则代表无需等待立即执行，并将开始时间设置为当前时间。若等待时间大于0则说明还没到执行时间，这时需要添加一个计时器`setTimeout`并设置延迟时间为等待时间。

1. **页面滚动加载**：当用户滚动页面到底部时，可以使用节流来限制触发加载更多内容的频率，以避免一次性加载过多内容导致页面性能下降。
2. **按钮点击事件**：当用户频繁点击按钮时，可以使用节流来限制按钮点击的频率，防止用户重复操作。
3. **鼠标移动事件**：当用户频繁移动鼠标时，可以使用节流来限制触发鼠标移动事件的频率，减少性能消耗。
4. **定时器操作**：当需要定时执行某个操作时，可以使用节流来限制操作的执行频率，以提高性能并避免资源浪费。

```js
function throttle(fn, delay) {
  let timeID = null; // 记录定时器ID
  let startTime = Date.now(); // 先设置开始时间
  return function () {
    let curTime = Date.now(); // 每次调用时获取一遍当前时间
    let awaitTime = delay - (curTime - startTime); // 等待时间

    if (timeID) clearTimeout(timeID); // 清除定时器
    if (awaitTime <= 0) {
      // 事件处理函数中，this 默认指向注册事件监听器的元素
      fn.apply(this, arguments); // 将函数的this绑定到到监听的元素上面，这样可以确保在fn中使用this操作元素
      startTime = Date.now(); // 重置开始时间
    } else {
      // 返回值 timeoutID 是一个正整数，表示由 setTimeout() 调用创建的定时器的编号。
      // 这个值可以传递给 clearTimeout() 来取消该定时器。
      timeID = setTimeout(fn, awaitTime);
    }
  };
}
```



## 防抖

**防抖**：n秒后执行触发的的事件处理函数，若在此期间再次触发，则重新计时。

1. **搜索框输入提示**：当用户在搜索框中输入时，可以使用防抖来延迟请求，只有在用户输入停止一段时间后才发送请求，减少不必要的请求次数。
2. **窗口大小调整**：当用户调整窗口大小时，浏览器会频繁触发 `resize` 事件，可以使用防抖来确保只在用户停止调整窗口大小后再执行相应的操作。
3. **表单验证**：当用户在表单输入框中输入时，可以使用防抖延迟验证用户输入的内容，减少频繁的验证操作，提升用户体验。
4. **滚动事件**：当用户滚动页面时，浏览器会频繁触发 `scroll` 事件，可以使用防抖来延迟处理滚动事件，以减少性能消耗。


```js
function debounce(fn, wait) {
  let timeID;

  return function () {
      // 若在此期间再次触发，则清空计时器重新计时。
      if(timeID) clearTimeout(timeID)
      // 在wait秒后触发
      timeID = setTimeout(function() {
          fn.apply(this, arguments)
      }, wait);
  }
}
```