# 响应式流程解析

## vue实例化过程

当执行 `new Vue({...})` 创建 Vue 实例时，发生了一系列的初始化步骤，让我们逐步了解：

1. **实例化过程：**
   - 创建一个新的 Vue 实例对象。
   - 初始化实例的各种内部属性。
2. **数据初始化：**
   - 对传入的配置对象进行解析，提取其中的数据、方法、生命周期钩子等。
   - 对 `data` 属性中的数据进行响应式处理，即将它们转换为响应式对象，使得数据变化时能够自动更新视图。
3. **模板编译：**
   - 如果提供了 `template` 属性，则将其编译成渲染函数。
   - 如果没有提供 `template` 属性，但提供了 `el` 属性，则会将 `el` 元素的内容作为模板进行编译。
4. **挂载阶段：**
   - 如果提供了 `el` 属性，则执行挂载操作，将 Vue 实例挂载到指定的 DOM 元素上。
   - 如果没有提供 `el` 属性，则需要手动调用 `vm.$mount()` 方法挂载到指定的 DOM 元素上。
5. **生命周期钩子：**
   - 执行生命周期钩子函数，比如 `beforeCreate`、`created` 等。
   - 在不同的生命周期阶段执行对应的逻辑，比如在 `created` 钩子中进行数据初始化或异步操作。
6. **Watcher 实例化：**
   - 在初始化阶段，会创建一些特定的 Watcher 实例，比如渲染 Watcher。
   - 这些 Watcher 实例会监听相应的数据变化，并在数据变化时执行更新操作，保持视图和数据的同步。
7. **事件监听器初始化：**
   - 如果提供了 `methods` 属性，则将其中的方法绑定到 Vue 实例上，使得可以通过 `this.methodName` 的方式在实例中调用这些方法。
8. **依赖收集：**
   - 在初始化过程中，会进行一次依赖收集的操作，建立起响应式数据与 Watcher 之间的关联关系，以便在数据变化时能够触发相应的更新操作。

总的来说，`new Vue({...})` 的过程就是将传入的配置对象进行解析和初始化，建立起 Vue 实例与数据、模板、生命周期钩子等之间的关联关系，以便后续的渲染和更新操作。



## Watcher分类

在 Vue 中，Watcher 主要分为以下几类：

1. **渲染 Watcher（Render Watcher）：**
   - 渲染 Watcher 是 Vue 实例在初始化渲染和之后的重新渲染过程中创建的 Watcher。
   - 它负责观察数据变化，并执行渲染函数来更新 DOM。
   - 当响应式数据发生变化时，渲染 Watcher 会重新执行渲染函数，更新视图。
2. **用户 Watcher（User Watcher）：**
   - 用户 Watcher 是由开发者通过 `$watch` 方法或组件选项中的 `watch` 属性创建的 Watcher。
   - 它用于观察特定的数据变化，并在数据变化时执行相应的回调函数。
   - 用户 Watcher 可以用于监听非响应式数据的变化，或者监听响应式数据的变化并执行一些额外的逻辑。
3. **计算属性 Watcher（Computed Watcher）：**
   - 计算属性 Watcher 是由计算属性所依赖的数据发生变化时创建的 Watcher。
   - 它负责观察计算属性的依赖数据的变化，并在需要时重新计算计算属性的值。
   - 计算属性 Watcher 会确保计算属性的值在依赖数据发生变化时被重新计算，但只在必要时才执行计算。



## 响应式

以上是vue实例化做的一些事情。其中我们重点讨论关于响应式方面的处理。

- data数据响应式转化，通过observer对象进行处理，底层基于Object.defineProperty()。
- 创建对应的watcher实例**记录依赖和观测依赖变化**。
- 依赖收集，建立watcher和响应式数据之间的关系，以便在数据变化时能够触发相应的更新操作。



​		对data对象中的属性进行响应式转化的时候，会为每一个property建立对应的dep实例，dep实例负责管理与该属性关联的一个或多个watcher实例（因为该属性会被多个vue组件共享，所以就会存在多个watcher实例的情况）。同时watcher实例内部也有一个deps数组用来记录它被哪些dep所管理，所以dep和watcher是多对多的关系。当响应式property被访问时会进行依赖收集，把当前活跃的watcher保存到dep中。当响应式property被更新时会通知该property对应的deps对watcher进行更新，watcher内部会调用updateComponent方法，然后通过这个方法去调用render函数生成vnodes，这时候会产生两颗虚拟dom树，之后在进行patch过程，这个过程通过diff算法比较新旧虚拟dom树将真正需要更新的节点计算出来最后调用createElm函数(该函数可以创建真实的dom节点)将更新的节点插入到真实dom中，上述流程大概时响应式从构建到更新的流程。注意在更新时，若property的dep需要更新非常多的watcher的时候，这时候vue中的调度器Scheduler会介入，它负责协调Watcher的执行时机，确保视图更新的高效性和流畅性。使用的是异步队列更新模型。Scheduler的核心思想是将视图的更新过程拆分成多个任务，然后通过异步队列的方式逐个执行这些任务，从而避免一次性更新大量DOM导致的性能问题。

​		为什么dep和watcher是多对多的关系呢？

1. 首先dep收集多个watcher是因为响应式property会被多个vue组件共享的情况，多以dep需要管理多个watcher。以便数据发生改变时通知所有用到该property的的watcher来触发更新。
2. 而watcher需要收集dep的原因时更新页面后需要watcher通过使用dep去清理更新前收集的watcher。每次更新页面时清理依赖的操作是为了确保依赖关系的准确性和可靠性。也是避免过多的watcher残留在dep中导致不必要的依赖最终和内存泄漏。

