# JS垃圾回收机制

## what is 内存泄漏

内存泄漏是指在计算机程序中，分配给程序使用的内存块在程序不再需要时未能被正确释从而导致内存持续堆积导致浏览器或应用崩溃的情况。

### 垃圾回收机制

​		垃圾回收机制是一种计算机程序或系统中的自动内存管理技术，用于识别和回收不再使用的内存资源，以便将其重新分配给其他用途。在许多编程语言中也对该机制进行了集成。例如我们的JS，支持垃圾回收机制，如果你的 JavaScript 应用程序经常发生崩溃、高延迟、性能差诸如此类事件，那么可能的一个原因就是存在内存泄漏。

**JS中的内存生命周期**：分配内存 - 使用内存 - 释放内存

JS中，程序中产生的对象会保存在堆内存中，可以根据引用链从根访问它们。垃圾收集器是 JavaScript 引擎中的一个后台进程，用于识别无法访问的对象、删除它们并回收内存。垃圾收集器会定期遍历引用链，并记录无法访问到的对象然后对其进行回收。



### 回收策略

#### 引用计数

这是最简单的垃圾回收算法之一。它的基本思想是跟踪每个值被引用的次数。当一个值的引用计数变为零时，就可以安全地释放这个值占用的内存。

例如，一个对象被赋值给一个变量时，该对象的引用计数就会增加1；当这个变量不再引用该对象时，对象的引用计数就会减少1。当引用计数变为0时，对象就会被垃圾回收机制回收。

```js
const o = {
  a: {
    b: 2,
  },
};
// 两个对象被创建，一个作为另一个的属性被引用，另一个被分配给变量 o
// 很显然，没有一个可以被垃圾收集

const o2 = o; // o2 变量“这个对象”的二次引用

o = 1; // 现在，“这个对象”只有一个 o2 变量的引用了，“这个对象”的原始引用 o 已经没有

const oa = o2.a; // oa变量引用了“这个对象”的 a 属性
// 现在，“这个对象”有两个引用了，一个是 o2，一个是 oa

o2 = "yo"; // 虽然最初的对象现在已经是零引用了，可以被垃圾回收了
// 但是它的属性 a 的对象还在被 oa 引用，所以还不能回收

oa = null; // a 属性的那个对象现在也是零引用了
// 它可以被垃圾回收了
```

缺点：无法解决**循环引用**的情况，即两个或多个对象相互引用，但它们之间没有被外部对象引用，导致它们的引用计数都不为零，即使它们已经不再被程序需要了，垃圾回收器也无法回收它们。

```js
function f() {
  const o = {};
  const o2 = {};
  o.a = o2; // o 引用 o2
  o2.a = o; // o2 引用 o

  return "azerty";
}

f();
```



#### 清除标记

​		这是目前主流的垃圾回收算法之一，它通过从根对象出发，标记所有从根对象可达的对象，然后清除未被标记的对象。这个过程确保保留了所有仍然可访问的对象，并回收了不可访问的对象。

标记清除算法的工作过程如下：

1. 从根对象开始，递归地标记所有从根对象可达的对象。
2. 清除所有未被标记的对象。

**tips**: 在现代JavaScript引擎中，通常会使用标记清除算法或其变种来进行垃圾回收。



### JS内存泄漏的原因

1. **未及时清理不再使用的引用**: 当不再需要使用的对象仍然被引用时，这些对象就无法被垃圾回收器清理，从而导致内存泄漏。这种情况通常发生在闭包、事件监听器或定时器等场景下，如果没有及时解除引用，这些对象就会一直存在于内存中。
2. **全局变量**: 在全局作用域中定义的变量会一直存在于内存中，直到页面关闭。如果大量的数据被存储在全局变量中且没有被及时释放，就会导致内存泄漏。
3. **DOM 引用**: 当页面中的 DOM 元素被 JavaScript 引用时，即使这些元素从 DOM 树中移除了，但仍然会存在内存中，直到相关引用被清除。
4. **循环引用**: 当两个或多个对象相互引用，且没有被其他对象引用时，这些对象就会形成循环引用。垃圾回收器无法识别这种情况，导致对象无法被释放。
5. **未释放的事件监听器**: 如果在页面中注册了大量的事件监听器，但在页面关闭或元素移除之前没有移除这些监听器，就会导致相关对象无法被垃圾回收。
6. **大型数据结构**: 当处理大量数据时，如果没有正确释放内存，就会导致内存泄漏。特别是在循环中创建临时对象或数组时，需要注意及时释放。
